# FX Carry Trade Strategy
# Quantpedia #0005: Currency Carry Trade
# Source: Deutsche Bank Currency Returns (2009)
#
# RULES:
# - Universe: 8 currency futures (AUD, GBP, CAD, EUR, JPY, MXN, NZD, CHF)
# - Signal: 3-month interbank rates from FRED
# - Long: Top 3 currencies by interest rate (high yield)
# - Short: Bottom 3 currencies by interest rate (low yield)
# - Weighting: Equal weight within long/short legs
# - Rebalancing: Monthly (first trading day)
#
# Currency Futures:
# A6 = Australian Dollar, B6 = British Pound, D6 = Canadian Dollar
# E6 = Euro, J6 = Japanese Yen, M6 = Mexican Peso
# N6 = New Zealand Dollar, S6 = Swiss Franc

# Data source - DAILY
src = market_data_source(timeframe=1D)()

# Continuous contract (passthrough for non-futures)
cont = futures_continuation(timeframe=1D, s_rollover_method=RolloverType.FirstOfMonth, s_adjustment_method=AdjustmentType.BackwardPanamaCanal)(src.o, src.h, src.l, src.c, src.v, src.oi, src.s)
close = cont.c

# Load 3-month interbank rates from FRED for each country
# OECD 3-Month Interbank Rates (Monthly)
# Use .result accessor to avoid observation_date type issues in join
ir_aud_src = economic_indicators(series_id="IR3TIB01AUM156N")()
ir_gbp_src = economic_indicators(series_id="IR3TIB01GBM156N")()
ir_cad_src = economic_indicators(series_id="IR3TIB01CAM156N")()
ir_eur_src = economic_indicators(series_id="IR3TIB01EZM156N")()
ir_jpy_src = economic_indicators(series_id="IR3TIB01JPM156N")()
ir_mxn_src = economic_indicators(series_id="IR3TIB01MXM156N")()
ir_nzd_src = economic_indicators(series_id="IR3TIB01NZM156N")()
ir_chf_src = economic_indicators(series_id="IR3TIB01CHM156N")()

# Forward fill to get daily values from monthly data
ir_aud_filled = ffill(ir_aud_src.result)
ir_gbp_filled = ffill(ir_gbp_src.result)
ir_cad_filled = ffill(ir_cad_src.result)
ir_eur_filled = ffill(ir_eur_src.result)
ir_jpy_filled = ffill(ir_jpy_src.result)
ir_mxn_filled = ffill(ir_mxn_src.result)
ir_nzd_filled = ffill(ir_nzd_src.result)
ir_chf_filled = ffill(ir_chf_src.result)

# Map interest rates to each currency future using is_asset_ref
is_aud = is_asset_ref(ticker="A6")()
is_gbp = is_asset_ref(ticker="B6")()
is_cad = is_asset_ref(ticker="D6")()
is_eur = is_asset_ref(ticker="E6")()
is_jpy = is_asset_ref(ticker="J6")()
is_mxn = is_asset_ref(ticker="M6")()
is_nzd = is_asset_ref(ticker="N6")()
is_chf = is_asset_ref(ticker="S6")()

# Assign interest rate to each asset (carry signal)
carry_signal = conditional_select(
  is_aud, ir_aud_filled,
  is_gbp, ir_gbp_filled,
  is_cad, ir_cad_filled,
  is_eur, ir_eur_filled,
  is_jpy, ir_jpy_filled,
  is_mxn, ir_mxn_filled,
  is_nzd, ir_nzd_filled,
  is_chf, ir_chf_filled,
  0.0
)

# Cross-sectional selection: top 3 (long) and bottom 3 (short)
is_top_3 = cs_select(direction=CSSelectDirection.top, mode=CSSelectMode.count, k=3)(carry_signal)
is_bottom_3 = cs_select(direction=CSSelectDirection.bottom, mode=CSSelectMode.count, k=3)(carry_signal)

# Detect first trading day of month
is_new_month = is_period_boundary(period=PeriodType.month)(index())

# Monthly rebalance signals
# Enter long when currency enters top 3 at month start
enter_long = is_new_month and is_top_3
exit_long = is_new_month and not is_top_3

# Enter short when currency enters bottom 3 at month start
enter_short = is_new_month and is_bottom_3
exit_short = is_new_month and not is_bottom_3

# Hold positions until next month rebalance
held_long = hold_until()(enter=enter_long, exit=exit_long)
held_short = hold_until()(enter=enter_short, exit=exit_short)

# Contract selection for futures rollover
rollover_policy()(active=cont.s)

# Entry/Exit zones
long_and_short_zone()(long_entry=held_long, short_entry=held_short)

# Equal weight across selected assets in each leg
# Long leg: +1/3 each (3 currencies)
# Short leg: -1/3 each (3 currencies)
long_weights = equal_weight()(held_long)
short_weights = equal_weight()(held_short)

# Position sizing - zone determines direction, size must be positive
position_weights = long_weights + short_weights

# Position sizing - ONLY rebalance on first trading day of month
position_size(type=SizeType.percent)(size=position_weights * 100, rebalance_on=is_new_month)
