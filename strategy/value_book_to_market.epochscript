Name: Value (Book-to-Market) Factor - Long-Short Strategy

Description: Quantpedia #0026: Value (Book-to-Market) Factor. Long stocks with highest B/M ratio (top decile - value), short stocks with lowest B/M ratio (bottom decile - growth). Monthly rebalancing, equal weighted.

Assets: NYSE, AMEX, NASDAQ
Data Source: polygon
Timeframe: 1D

================================================================================

# Value (Book-to-Market) Factor - Long-Short Strategy
# Quantpedia #0026: Value (Book-to-Market) Factor
# Source: Fama-French (1992), Asness, Frazzini, Israel, Moskowitz (2015)
#
# RULES:
# - Universe: NYSE, AMEX, NASDAQ stocks
# - Signal: Book-to-Market ratio = Book Value / Market Cap
# - Selection:
#   - Long: Top decile (highest 10% B/M) - VALUE stocks - expect outperformance
#   - Short: Bottom decile (lowest 10% B/M) - GROWTH stocks - expect underperformance
# - Weighting: Equal weight within each leg
# - Rebalancing: Monthly (first trading day)

# Data source - DAILY
src = market_data_source(timeframe=1D)()
close = src.c

# =============================================================================
# BOOK-TO-MARKET SIGNAL
# =============================================================================

# Get shares outstanding from income statement (quarterly data)
income_stmt = income_statement(period=ReportingPeriod.quarterly)()

# Get total equity from balance sheet (quarterly data)
balance = balance_sheet(period=ReportingPeriod.quarterly)()

# Get book-to-market ratio directly from finance_ratio transform
# B/M = Book Value (total_equity) / Market Cap (close * basic_shares)
book_to_market = finance_ratio(ratio_type=FinanceRatioType.book_to_market, period=ReportingPeriod.quarterly)(c=close, basic_shares=income_stmt.basic_shares, total_equity=balance.total_equity)

# Filter for valid B/M values (positive)
bm_valid = book_to_market > 0
book_to_market_filtered = where(bm_valid, book_to_market)

# Forward fill to handle gaps between data updates
book_to_market_filled = ffill(book_to_market_filtered)

# =============================================================================
# CROSS-SECTIONAL SELECTION
# =============================================================================

# Top 10% by B/M (high B/M - VALUE - LONG)
is_high_bm = cs_select(direction=CSSelectDirection.top, mode=CSSelectMode.percent, k=10)(book_to_market_filled)

# Bottom 10% by B/M (low B/M - GROWTH - SHORT)
is_low_bm = cs_select(direction=CSSelectDirection.bottom, mode=CSSelectMode.percent, k=10)(book_to_market_filled)

# =============================================================================
# MONTHLY REBALANCING
# =============================================================================

# Detect first trading day of month
is_new_month = is_period_boundary(period=PeriodType.month)(index())

# LONG signals - high B/M (value) stocks
enter_long = is_new_month and is_high_bm
exit_long = is_new_month and not is_high_bm
held_long = hold_until()(enter=enter_long, exit=exit_long)

# SHORT signals - low B/M (growth) stocks
enter_short = is_new_month and is_low_bm
exit_short = is_new_month and not is_low_bm
held_short = hold_until()(enter=enter_short, exit=exit_short)

# =============================================================================
# POSITION SIZING
# =============================================================================

# long_and_short_zone handles direction: +1 (long), -1 (short), 0 (flat)
long_and_short_zone()(long_entry=held_long, short_entry=held_short)

# Equal weight across ALL active positions (both long and short)
is_active = held_long or held_short
weights = equal_weight()(is_active)

# Position sizing - size is always positive, direction from long_and_short_zone
position_size(type=SizeType.percent)(size=weights * 100, rebalance_on=is_new_month)
